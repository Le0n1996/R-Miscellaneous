install.packages("Rcmdr") # Загрузить из репозитория R пакет "Rcmdr"

### №13.1
a <- sin(factorial(7)+choose(32,11))^3  # Аргумент синуса помещен в переменную a
b <- sqrt(1 + atan(1/(1+0.2435)))       # Знаменатель помещен в переменную b
c <- 2^(-3)+a/b                         # Подлогарифменное выражение помещено в переменную c
d <- log(c, 48.23)                      # Значение выражения помещено в переменную d
signif(d, 6)				                    # Ответ: берём 6 значащих цифр


### №13.2
a <- tanh(12)^(-3)*exp(-1/4.8)          # Числитель второй дроби помещен в переменную a
b <- abs(log(256/1809.43, 13.76))       # Модуль, стоящий в знаменателе, помещен в переменную b
c <- sqrt(b + atan(7^(-3)))             # Знаменатель помещен в переменную c
d <- 1/(0.3532)^(1/3)                   # Первое слагаемое помещено в переменную d
e <- d - a/c                            # Значение выражения внутри косинуса помещено в переменную e
f <- cos(e)^(-1)                        # Значение выражения помещено в переменную f
round(f, 3)	                            # Ответ: берём 3 цифры после запятой


### №13.3
for (i in 1:5) # способ проверить значения в 1/10, 1/100, 1/1000, 1/10000, 1/100000
  print(paste('В точке', 0.1^i, 'значение синуса равно', sin(0.1^i)))
# Как мы можем видеть, чем меньше значение x, тем точнее приближение
# Для косинуса:
for (i in 1:5) # способ проверить значения в 1/10, 1/100, 1/1000, 1/10000, 1/100000
  print(paste('В точке', 0.1^i, 'значение косинуса равно', cos(0.1^i)))
# и будет верно приближение cos(x) ??? 1 - x^2/2 (опять же, чем меньше х, тем точнее)
# Это, на самом деле, первые члены рядов Маклорена (рядов Тейлора в 0)


### №14.1
Separate <- function(x) { # Задание функции Separate(x)
  f <- floor(x)           # Вычисление целой части в переменной f
  d <- x - f              # Вычисление дробной части в переменной c
  return(c(f, d))         # Возврат значений f и c
}
x <- seq(-3, 3, 0.05)     # Последовательность чисел от -3 до 3 с шагом 0.05, записанная в x
wh <- Separate(x)[1:length(x)] # Извлекаем все целые части
fr <- Separate(x)[(length(x)+1):(2*length(x))] # Извлекаем все дробные части
plot(x, wh, type = "l", ylab = 'Whole part of x') # График целой части х
plot(x, fr, type = "l", ylab = 'Fractional part of x') # График дробной части х


### №14.2
Sink <- function(x) {sin(x)/x} # Задаем функцию Sink(x)
x <- seq(-20, 20, length.out = 401) # создаем последовательность из 401 числа от -20 до 20
plot(x, Sink(x), type = "l", ylab = 'sin(x) / x') # График функции sin(х)/x
Sink(0) # Вычисляем значение этой функции в точке 0
# Это значение равно NaN, то есть в 0 функция не определена,
# а значит, функция Sink(x) в нуле не является непрерывной


### №14.3
h <- function(x, y, a = 3) {
  res <- ifelse ((x == 0 & y == 0), 'Функция не определена', a + x/y)
    return(res)
} # Задаем функцию h(x,y,a)
h(2,-2) # правильный ответ 2
h(6,3,2) # правильный ответ 4
h(0,0,5) # возвращает сообщение об ошибке
h(-2,0,3) # Правильно возвращает -infty


### №14.4
S <- function(x)      # Объявление функции S(x)
{
  A <- (x<0)          # Создаем массив из "TRUE/да" и "FALSE/нет" для x < 0
  B <- (x>=0)&(x<=2)  # Создаем массив из "TRUE/да" и "FALSE/нет" для (x >= 0) и (x <= 2)
  D <- (x>2)          # Создаем массив из "TRUE/да" и "FALSE/нет" для x > 2
  x[A] <- sin(2*x[A]) # Вычисляем левую ветвь функции
  x[B] <- x[B]^2      # Вычисляем середину функции
  x[D] <- 6 - x[D]    # Вычисляем правую ветвь функции
  Res <- x                     
  return(Res)         # Возвращаем Res
}
x <- seq(-7, 7, 0.01)  # Последовательность чисел от -7 до 7 с шагом 0.05
A <- x[x<0]            # Отдельно множество А 
B <- x[0<=x & x<=2]    # Отдельно множество B
D <- x[2<x]            # Отдельно множество D
plot(A, S(A), type = "l",lwd = 2,col="red", xlim=c(-7, 7), ylim = c(-2,5), xlab = 'x', ylab = 'S(x)') # Строим график y=S(A)
lines(B, S(B), type = "l",lwd = 2,col="green")  # Строим график y=S(B)
lines(D, S(D), type = "l",lwd = 2,col="blue")   # Строим график y=S(D)
abline(h = 0, v = 0, col = "gray40")            # Рисуем оси координат


### №15.1
f <- function(x) {x^3 - 6*x + 9}  # Задаем функцию 
dx <- 0.0001                      # Задаем точность по аргументу x
x <- seq(-5, 5, by = dx)          # Разбиваем отрезок [-5; 5] с шагом dx
plot(x, f(x), type = "l", lwd = 2, col = "blue")
abline(h = 0, v = 0, col = "gray40")      # Рисуем оси координат
# Отмечаем точки корней желтым цветом с красной границей:    
points(c(-3), c(f(-3)), col = "red", pch = 21, bg = "yellow") 
text(-2.7,-10,"A", col = "red")
points(c(-sqrt(2)), c(f(-sqrt(2))), col = "red", pch = 21, bg = "yellow") 
text(-sqrt(2),30,"Max", col = "red")  
points(c(sqrt(2)), c(f(sqrt(2))), col = "red", pch = 21, bg = "yellow") 
text(sqrt(2),20,"Min", col = "red")
points(c(0), c(f(0)), col = "red", pch = 21, bg = "yellow") 
text(0,25,"Bend", col = "red")  
# Точно находим корень:
dx <- 0.0000001           # Шаг dx (точность определения точки корня)
a <- -4; b <- -2          # Задаем концы интервала, где ищем корень  
uniroot(f,c(a,b),tol=dx)  # Как мы видим, корень равен -3

dx <- 0.0000001           # Шаг dx (точность определения точки корня)
x <- seq(-2, 0, by = dx)  # Выделили разбиение окрестности локального максимума 
i <- which.max(f(x))      # Нашли номер точки, которая на этом отрезке дает максимум
x[i]                      # Точка локального максимума для f
f(x[i])                   # Значение функции f в локальном максимуме
# Как мы можем видеть, это точка (-sqrt(2); 9+4*sqrt(2))

dx <- 0.0000001           # Шаг dx (точность определения точки корня)
x <- seq(0, 2, by = dx)   # Выделили разбиение окрестности локального максимума 
i <- which.min(f(x))      # Нашли номер точки, которая на этом отрезке дает максимум
x[i]                      # Точка локального максимума для f
f(x[i])                   # Значение функции f в локальном минимуме
# Как мы можем видеть, это точка (sqrt(2); 9-4*sqrt(2))

f2 <- function(x) {6*x}   # Задаем вторую производную f 
dx <- 0.0000001           # Шаг dx (точность определения точки корня)
a <- -1; b <- 1           # Задаем концы интервала, где ищем корень (ноль второй производной),
# а третья производная заведомо положительна и равна 6
uniroot(f2,c(a,b),tol=dx) # Как мы видим, точка перегиба достигается при х = 0
f(0) # и при этом f(x) = f(0) = 9

# Аналитически получаем корень x=-3 ((-3)^3 - 6(-3) + 9 = 0)
# Локальные максимум и минимум: (-sqrt(2); 9+4*sqrt(2)), (sqrt(2); 9-4*sqrt(2))
# Точка перегиба: (0; 9)


### №15.2
f <- function(x) {(1.3*x^4 - 3*x^3 + 2*x - 0.2)/(x^4 + 3)}  # Задаем функцию 
dx <- 0.0001                      # Задаем точность по аргументу x
x <- seq(-5, 5, by = dx)          # Разбиваем отрезок [-5; 5] с шагом dx
plot(x, f(x), type = "l", lwd = 2, col = "blue")
abline(h = 0, v = 0, col = "gray40")      # Рисуем оси координат

# Ищем приближенные координаты корней и отмечаем их на рисунке:
dx <- 0.0000001           # Шаг dx (точность определения точки корня)
a <- -2; b <- 0           # Задаем концы интервала, где ищем первый корень
uniroot(f, c(a,b), tol=dx)$root # получилось -0.7543446
points(c(-0.7543446), c(f(-0.7543446)), col = "red", pch = 21, bg = "yellow") 
text(-0.9543446,0,"A", col = "red")

dx <- 0.0000001           # Шаг dx (точность определения точки корня)
a <- 0; b <- 0.5          # Задаем концы интервала, где ищем второй корень
uniroot(f, c(a,b), tol=dx)$root # получилось 0.1014995
points(c(0.1014995), c(f(0.1014995)), col = "red", pch = 21, bg = "yellow") 
text(0.0014995,0.1,"B", col = "red")

dx <- 0.0000001           # Шаг dx (точность определения точки корня)
a <- 0.5; b <- 1.5        # Задаем концы интервала, где ищем третий корень
uniroot(f, c(a,b), tol=dx)$root # получилось 1.053821
points(c(1.053821), c(f(1.053821)), col = "red", pch = 21, bg = "yellow") 
text(0.953821,-0.09,"C", col = "red")

dx <- 0.0000001           # Шаг dx (точность определения точки корня)
a <- 1.5; b <- 2.5        # Задаем концы интервала, где ищем четвертый корень
uniroot(f, c(a,b), tol=dx)$root # получилось 1.906716
points(c(1.906716), c(f(1.906716)), col = "red", pch = 21, bg = "yellow") 
text(2.106716,-0.07,"D", col = "red")

# Ищем приближенные координаты локальных экстремумов и отмечаем их на рисунке:
dx <- 0.0000001           # Шаг dx (точность определения точки)
x <- seq(-3, -1, by = dx) # Выделили разбиение окрестности локального максимума 
i <- which.max(f(x))      # Нашли номер точки, которая на этом отрезке дает максимум
x[i]                      # Точка локального максимума для f
f(x[i])                   # Значение функции f в локальном максимуме
# В итоге получилась точка (-2.402877, 2,200338)
points(c(x[i]), c(f(x[i])), col = "green", pch = 21, bg = "yellow") 
text(x[i],f(x[i])-0.11,"E", col = "green")

dx <- 0.0000001           # Шаг dx (точность определения точки)
x <- seq(-1, 0, by = dx)  # Выделили разбиение окрестности локального максимума 
i <- which.min(f(x))      # Нашли номер точки, которая на этом отрезке дает максимум
x[i]                      # Точка локального максимума для f
f(x[i])                   # Значение функции f в локальном максимуме
# В итоге получилась точка (-0.4154666, -0.2564713)
points(c(x[i]), c(f(x[i])), col = "green", pch = 21, bg = "yellow") 
text(x[i]-0.38,f(x[i]),"F", col = "green")

dx <- 0.0000001           # Шаг dx (точность определения точки)
x <- seq(0, 1, by = dx)   # Выделили разбиение окрестности локального максимума 
i <- which.max(f(x))      # Нашли номер точки, которая на этом отрезке дает максимум
x[i]                      # Точка локального максимума для f
f(x[i])                   # Значение функции f в локальном максимуме
# В итоге получилась точка (0.5552987, 0.1681752)
points(c(x[i]), c(f(x[i])), col = "green", pch = 21, bg = "yellow") 
text(x[i],f(x[i])+0.11,"G", col = "green")

dx <- 0.0000001           # Шаг dx (точность определения точки)
x <- seq(1, 2, by = dx)   # Выделили разбиение окрестности локального максимума 
i <- which.min(f(x))      # Нашли номер точки, которая на этом отрезке дает максимум
x[i]                      # Точка локального максимума для f
f(x[i])                   # Значение функции f в локальном максимуме
# В итоге получилась точка (1.441054, -0.09427563)
points(c(x[i]), c(f(x[i])), col = "green", pch = 21, bg = "yellow") 
text(x[i],f(x[i])-0.1,"H", col = "green")

# Итого, координаты точек:
# A = (-0.7543446; 0), B = (0.1014995; 0)
# C = (1.053821; 0), D = (1.906716; 0)
# E = (-2.402877, 2,200338), F = (-0.4154666, -0.2564713)
# G = (0.5552987, 0.1681752), H = (1.441054, -0.09427563)

# Добавляем пунктирную асимптоту; в пределе имеем 1.3x^4/x^4, поэтому
# асимптота имеет вид горизонтальной прямой y = 1.3
dx <- 0.0001                    
x <- seq(-5, 5, by = dx)
cons = rep(1.3, length(x))
lines(x, cons, col = "brown", lty = "44")
text(4,1.47,"y = 1.3", col = "brown")


### №15.3
f <- function(x) {x^4 - 2*x^3 - 8*x^2 + 18*x - 9}  # Задаем функцию 
dx <- 0.0001                      # Задаем точность по аргументу x
x <- seq(-3.5, 3.5, by = dx)      # Разбиваем отрезок [-3.5; 3.5] с шагом dx
plot(x, f(x), type = "l", lwd = 2, col = "blue")
abline(h = 0, v = 0, col = "gray40")      # Рисуем оси координат

# Ищем приблизительные координаты корней:
dx <- 0.0000001           # Шаг dx (точность определения точки корня)
a <- -4; b <- -2           # Задаем концы интервала, где ищем первый корень
xi <- uniroot(f, c(a,b), tol=dx)$root 
xi # получилось -3

dx <- 0.0000001           # Шаг dx (точность определения точки)
x <- seq(0, 2, by = dx)   # Выделили разбиение окрестности локального максимума 
i <- which.max(f(x))      # Нашли номер точки, которая на этом отрезке дает максимум
x[i] # Так как значение x[1] не больше 0, других корней тут нет

dx <- 0.0000001           # Шаг dx (точность определения точки корня)
a <- 2; b <- 4           # Задаем концы интервала, где ищем первый корень
xi <- uniroot(f, c(a,b), tol=dx)$root 
xi # получилось 3

# Ищем приблизительные координаты локальных экстремумов:
dx <- 0.0000001           # Шаг dx (точность определения точки)
x <- seq(-3, -1, by = dx) # Выделили разбиение окрестности локального минимума 
i <- which.min(f(x))      # Нашли номер точки, которая на этом отрезке дает минимум
x[i]                      # Точка локального минимума для f
f(x[i])                   # Значение функции f в локальном минимуме
# В итоге получилась точка (-1.886001, -45.33476)

# Точка (1,0) дает локальный максимум из упомянутых соображений

dx <- 0.0000001           # Шаг dx (точность определения точки)
x <- seq(2, 3, by = dx)   # Выделили разбиение окрестности локального минимума 
i <- which.min(f(x))      # Нашли номер точки, которая на этом отрезке дает минимум
x[i]                      # Точка локального минимума для f
f(x[i])                   # Значение функции f в локальном минимуме
# В итоге получилась точка (2.386001, -6.352741)

# Теперь ищем точки перегиба: определяем вторую производную:
f2 <- function(x) {12*x^2 - 12*x - 16}  # Задаем функцию 
dx <- 0.0001                      # Задаем точность по аргументу x
x <- seq(-3.5, 3.5, by = dx)      # Разбиваем отрезок [-3.5; 3.5] с шагом dx
plot(x, f2(x), type = "l", lwd = 2, col = "blue")
abline(h = 0, v = 0, col = "gray40")      # Рисуем оси координат

# Перегибы могут достигаться, когда вторая производная равна 0, поэтому ищем корни
dx <- 0.0000001           # Шаг dx (точность определения точки корня)
a <- -1; b <- 0           # Задаем концы интервала, где ищем первый корень
xi <- uniroot(f2, c(a,b), tol=dx)$root 
xi    # получилось -0.7583057
f(xi) # получилось -26.04697
dx <- 0.0000001           # Шаг dx (точность определения точки корня)
a <- 1; b <- 2           # Задаем концы интервала, где ищем первый корень
xi <- uniroot(f2, c(a,b), tol=dx)$root 
xi    # получилось 1.758306
f(xi) # получилось -3.397471

# Итого, координаты:
# Корни: (-3; 0), (1; 0), (3; 0)
# Локальные экстремумы: (-1.886001; -45.33476), (1; 0), (2.386001; -6.352741)
# Перегибы: (-0.7583057; -26.04697), (1.758306; -3.397471)
# Как мы можем видеть, никакой из кандидатов на перегиб не является
# локальным экстремумом, поэтому в обеих точках находятся перегибы


### №16.1
# Для точного решения первообразная получается равной 0.75(x-2)^(4/3),
# и интеграл в точности равен 3/4-3/2*2^(1/3)
g <- function(x) {-(2-x)^(1/3)}                # Объявление функции g(x)=-(2-x)^(1/3); ошибка возникает при попытке извлечь корень из отрицательного числа
Integral_exactly <- 0.75 - 1.5*2^(1/3)         # Точное значение интеграла
Integral_numerical <- integrate(g, 0, 1)$value # Приближенное значение интеграла

abs(Integral_exactly - Integral_numerical)     # Модуль истинной ошибки
integrate(g, 0, 1)$abs.error                   # Оценка модуля абсолютной погрешности
Integral_numerical                             # Приближенное значение интеграла
# получается, что R считает, что есть ошибка порядка 10^(-14), а на деле ошибки нет вовсе
# Бороться с этим можно с помощью параметров abs.tol и rel.tol, которые
# позволяют установить желаемую точность


### №16.2
# Для точного решения интегрируем по частям: получаем первообразную,
# равную x^2*sin(x)+2*x*cos(x)-2*sin(x), и интеграл в точности равен pi^2/4 - 2
# Приближенное решение:
g <- function(x) {x^2*cos(x)}                 # Объявление функции g(x) = x^2*cos(x)
Integral_exactly <- pi^2/4 - 2                # Точное значение интеграла
Integral_numerical <- integrate(g, 0, pi/2)$value # Приближенное значение интеграла

abs(Integral_exactly - Integral_numerical)    # Модуль истинной ошибки
integrate(g, 0, pi/2)$abs.error               # Оценка модуля абсолютной погрешности
Integral_numerical                            # Приближенное значение интеграла
# Как мы видим, приближенное решение практически не отличается от точного
# Оценка модуля абсолютной ошибки в R и реальное расхождение ответов
# отличаются между собой на один порядок (и реальная ошибка меньше)


### №16.3а
# Фигура ограничена условиями -2<=x<=2 и 0<=y<=4-x^2
g <- function(x) {4-x^2}                   # Объявление функции g(x) = x^2*cos(x)
Integral_exactly <- 32/3                   # Точное значение интеграла
Integral_numerical <- integrate(g, -2, 2)$value # Приближенное значение интеграла

abs(Integral_exactly - Integral_numerical) # Модуль истинной ошибки
integrate(g, -2, 2)$abs.error              # Оценка модуля абсолютной погрешности
Integral_numerical                         # Приближенное значение интеграла
### №16.3b
# Фигура ограничена условиями 0<=x<=1 и 0<=y<=x^(-1/3)
g <- function(x) {x^(-1/3)}                # Объявление функции g(x) = x^2*cos(x)
Integral_exactly <- 3/2                    # Точное значение интеграла
Integral_numerical <- integrate(g, 0, 1)$value # Приближенное значение интеграла

abs(Integral_exactly - Integral_numerical) # Модуль истинной ошибки
integrate(g, 0, 1)$abs.error               # Оценка модуля абсолютной погрешности
Integral_numerical                         # Приближенное значение интеграла, которое равно 1,5


### №17.1
f  <- function(x, y) {y*exp(-x^2)}     # Объявляем функцию f(x,y)
x  <- seq(-5, 5, by=0.5)               # Задаем последовательность значений x
y  <- seq(-5, 5, by=0.5)               # Задаем последовательность значений y
z  <- outer(x, y, f)                   # Вычисляем значение функции во всех парах (x,y)
persp(x, y, z, theta=30, phi=30, col="green", ticktype="detailed", 
      main="f(x,y)")                   # График поверхности f(x,y)


### №17.2
install.packages("plot3D")
library(plot3D)
x <- y <-  0:50                     # x и y задаем как последовательности от 0 до 50 с шагом 1
f <- function(x,y) {x^0.85*y^0.15}  # Задаем функцию f
z <- outer(x, y, f)                 # Вычисляем f во всех точках объявленной сетки (x,y) 
contour(x, y, z, ylim = c(0, 50), nlev = 20, lty = 2, method = "simple",
        main = "20 levels; \"simple\" labelling method")


### №17.3
library(plot3D)

f <- function(x,y) {x^3 - 3600*x - 50*y^2}                                   # Объявляем функцию f(x,y)
M <- mesh(seq(-100, 100, by = 0.5), seq(-100, 100, by = 0.5))   # Разбиваем сеть (ui, vj)
u <- M$x             # Вводим разбиение параметра u (это набор ui)                                              
v <- M$y             # Вводим разбиение параметра v (это набор vj)

x <- u               # Вводим функцию для координаты x поверхности
y <- v               # Вводим функцию для координаты y поверхности
z <- f(u,v)          # Вводим функцию для координаты z поверхности

surf3D(x, y, z, colvar = z, phi = 30, bty = "b2",theta = 50,
       lighting = TRUE, ltheta = 40, colkey = TRUE, box = TRUE)  # Построение поверхности 

surf3D(x, y, z, colvar = z, phi = 15, bty = "b2",theta = 50,
       lighting = TRUE, ltheta = 30, colkey = TRUE, box = TRUE)  # Построение поверхности 

surf3D(x, y, z, colvar = z, phi = 30, bty = "b2",theta = 5,
       lighting = TRUE, ltheta = 30, colkey = TRUE, box = TRUE)  # Построение поверхности 